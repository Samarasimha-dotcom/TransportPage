{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport class RideService {\n  constructor() {\n    this.STORAGE_KEY_PREFIX = 'rides_';\n    this.TIME_BUFFER_MINUTES = 60;\n  }\n  todayKey() {\n    const d = new Date();\n    const yyyy = d.getFullYear();\n    const mm = String(d.getMonth() + 1).padStart(2, '0');\n    const dd = String(d.getDate()).padStart(2, '0');\n    return `${yyyy}-${mm}-${dd}`;\n  }\n  storageKeyForToday() {\n    return this.STORAGE_KEY_PREFIX + this.todayKey();\n  }\n  loadTodayRides() {\n    const key = this.storageKeyForToday();\n    const raw = localStorage.getItem(key);\n    return raw ? JSON.parse(raw) : [];\n  }\n  saveTodayRides(rides) {\n    const key = this.storageKeyForToday();\n    localStorage.setItem(key, JSON.stringify(rides));\n  }\n  toMinutes(time) {\n    const [h, m] = time.split(':').map(Number);\n    return h * 60 + m;\n  }\n  withinBuffer(target, reference) {\n    const t = this.toMinutes(target);\n    const r = this.toMinutes(reference);\n    return Math.abs(t - r) <= this.TIME_BUFFER_MINUTES;\n  }\n  addRide(input) {\n    // basic validations\n    if (!input.ownerEmployeeId.trim()) return {\n      ok: false,\n      error: 'Employee ID is required'\n    };\n    if (!input.vehicleNo.trim()) return {\n      ok: false,\n      error: 'Vehicle No is required'\n    };\n    if (!input.pickupPoint.trim()) return {\n      ok: false,\n      error: 'Pick-up Point is required'\n    };\n    if (!input.destination.trim()) return {\n      ok: false,\n      error: 'Destination is required'\n    };\n    if (!/^\\d{2}:\\d{2}$/.test(input.time)) return {\n      ok: false,\n      error: 'Time must be HH:mm'\n    };\n    if (input.vacantSeats == null || input.vacantSeats < 0) return {\n      ok: false,\n      error: 'Vacant Seats must be >= 0'\n    };\n    const rides = this.loadTodayRides();\n    // Employee ID unique for ride owners for today\n    const existsOwner = rides.some(r => r.ownerEmployeeId === input.ownerEmployeeId);\n    if (existsOwner) {\n      return {\n        ok: false,\n        error: 'This employee has already added a ride today'\n      };\n    }\n    const ride = {\n      id: crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2),\n      ownerEmployeeId: input.ownerEmployeeId.trim(),\n      vehicleType: input.vehicleType,\n      vehicleNo: input.vehicleNo.trim(),\n      vacantSeats: input.vacantSeats,\n      time: input.time,\n      pickupPoint: input.pickupPoint.trim(),\n      destination: input.destination.trim(),\n      bookings: [],\n      createdAt: Date.now()\n    };\n    rides.push(ride);\n    this.saveTodayRides(rides);\n    return {\n      ok: true\n    };\n  }\n  listRides(options) {\n    const rides = this.loadTodayRides();\n    let result = rides.slice();\n    if (options?.vehicleType && options.vehicleType !== 'All') {\n      result = result.filter(r => r.vehicleType === options.vehicleType);\n    }\n    if (options?.excludeOwner) {\n      result = result.filter(r => r.ownerEmployeeId !== options.excludeOwner);\n    }\n    if (options?.onlyWithSeats) {\n      result = result.filter(r => r.vacantSeats > 0);\n    }\n    // Time matching with +/- 60 minutes if a reference is given, else use current time\n    const ref = options?.timeReference || this.currentTimeHHmm();\n    result = result.filter(r => this.withinBuffer(r.time, ref));\n    // sort by time ascending\n    result.sort((a, b) => this.toMinutes(a.time) - this.toMinutes(b.time));\n    return result;\n  }\n  bookRide(rideId, employeeId) {\n    if (!employeeId.trim()) return {\n      ok: false,\n      error: 'Employee ID is required'\n    };\n    const rides = this.loadTodayRides();\n    const idx = rides.findIndex(r => r.id === rideId);\n    if (idx === -1) return {\n      ok: false,\n      error: 'Ride not found'\n    };\n    const ride = rides[idx];\n    if (ride.ownerEmployeeId === employeeId) {\n      return {\n        ok: false,\n        error: 'You cannot book your own ride'\n      };\n    }\n    if (ride.bookings.includes(employeeId)) {\n      return {\n        ok: false,\n        error: 'You cannot book the same ride twice'\n      };\n    }\n    if (ride.vacantSeats <= 0) {\n      return {\n        ok: false,\n        error: 'No vacant seats available'\n      };\n    }\n    ride.bookings.push(employeeId);\n    ride.vacantSeats -= 1;\n    rides[idx] = ride;\n    this.saveTodayRides(rides);\n    return {\n      ok: true\n    };\n  }\n  currentTimeHHmm() {\n    const d = new Date();\n    const hh = String(d.getHours()).padStart(2, '0');\n    const mm = String(d.getMinutes()).padStart(2, '0');\n    return `${hh}:${mm}`;\n  }\n  static {\n    this.ɵfac = function RideService_Factory(t) {\n      return new (t || RideService)();\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: RideService,\n      factory: RideService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["RideService","constructor","STORAGE_KEY_PREFIX","TIME_BUFFER_MINUTES","todayKey","d","Date","yyyy","getFullYear","mm","String","getMonth","padStart","dd","getDate","storageKeyForToday","loadTodayRides","key","raw","localStorage","getItem","JSON","parse","saveTodayRides","rides","setItem","stringify","toMinutes","time","h","m","split","map","Number","withinBuffer","target","reference","t","r","Math","abs","addRide","input","ownerEmployeeId","trim","ok","error","vehicleNo","pickupPoint","destination","test","vacantSeats","existsOwner","some","ride","id","crypto","randomUUID","random","toString","slice","vehicleType","bookings","createdAt","now","push","listRides","options","result","filter","excludeOwner","onlyWithSeats","ref","timeReference","currentTimeHHmm","sort","a","b","bookRide","rideId","employeeId","idx","findIndex","includes","hh","getHours","getMinutes","factory","ɵfac","providedIn"],"sources":["/home/innoppl/Documents/Personal Work/Infrrd/transport/src/app/services/ride.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Ride, VehicleType } from '../models/ride.model';\n\n@Injectable({ providedIn: 'root' })\nexport class RideService {\n  private readonly STORAGE_KEY_PREFIX = 'rides_';\n  private readonly TIME_BUFFER_MINUTES = 60;\n\n  private todayKey(): string {\n    const d = new Date();\n    const yyyy = d.getFullYear();\n    const mm = String(d.getMonth() + 1).padStart(2, '0');\n    const dd = String(d.getDate()).padStart(2, '0');\n    return `${yyyy}-${mm}-${dd}`;\n  }\n\n  private storageKeyForToday(): string {\n    return this.STORAGE_KEY_PREFIX + this.todayKey();\n  }\n\n  private loadTodayRides(): Ride[] {\n    const key = this.storageKeyForToday();\n    const raw = localStorage.getItem(key);\n    return raw ? (JSON.parse(raw) as Ride[]) : [];\n  }\n\n  private saveTodayRides(rides: Ride[]) {\n    const key = this.storageKeyForToday();\n    localStorage.setItem(key, JSON.stringify(rides));\n  }\n\n  private toMinutes(time: string): number {\n    const [h, m] = time.split(':').map(Number);\n    return h * 60 + m;\n  }\n\n  private withinBuffer(target: string, reference: string): boolean {\n    const t = this.toMinutes(target);\n    const r = this.toMinutes(reference);\n    return Math.abs(t - r) <= this.TIME_BUFFER_MINUTES;\n  }\n\n  addRide(input: {\n    ownerEmployeeId: string;\n    vehicleType: VehicleType;\n    vehicleNo: string;\n    vacantSeats: number;\n    time: string; // HH:mm\n    pickupPoint: string;\n    destination: string;\n  }): { ok: true } | { ok: false; error: string } {\n    // basic validations\n    if (!input.ownerEmployeeId.trim()) return { ok: false, error: 'Employee ID is required' };\n    if (!input.vehicleNo.trim()) return { ok: false, error: 'Vehicle No is required' };\n    if (!input.pickupPoint.trim()) return { ok: false, error: 'Pick-up Point is required' };\n    if (!input.destination.trim()) return { ok: false, error: 'Destination is required' };\n    if (!/^\\d{2}:\\d{2}$/.test(input.time)) return { ok: false, error: 'Time must be HH:mm' };\n    if (input.vacantSeats == null || input.vacantSeats < 0) return { ok: false, error: 'Vacant Seats must be >= 0' };\n\n    const rides = this.loadTodayRides();\n\n    // Employee ID unique for ride owners for today\n    const existsOwner = rides.some(r => r.ownerEmployeeId === input.ownerEmployeeId);\n    if (existsOwner) {\n      return { ok: false, error: 'This employee has already added a ride today' };\n    }\n\n    const ride: Ride = {\n      id: crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2),\n      ownerEmployeeId: input.ownerEmployeeId.trim(),\n      vehicleType: input.vehicleType,\n      vehicleNo: input.vehicleNo.trim(),\n      vacantSeats: input.vacantSeats,\n      time: input.time,\n      pickupPoint: input.pickupPoint.trim(),\n      destination: input.destination.trim(),\n      bookings: [],\n      createdAt: Date.now(),\n    };\n\n    rides.push(ride);\n    this.saveTodayRides(rides);\n    return { ok: true };\n  }\n\n  listRides(options?: { vehicleType?: VehicleType | 'All'; timeReference?: string; excludeOwner?: string; onlyWithSeats?: boolean }): Ride[] {\n    const rides = this.loadTodayRides();\n    let result = rides.slice();\n\n    if (options?.vehicleType && options.vehicleType !== 'All') {\n      result = result.filter(r => r.vehicleType === options.vehicleType);\n    }\n\n    if (options?.excludeOwner) {\n      result = result.filter(r => r.ownerEmployeeId !== options.excludeOwner);\n    }\n\n    if (options?.onlyWithSeats) {\n      result = result.filter(r => r.vacantSeats > 0);\n    }\n\n    // Time matching with +/- 60 minutes if a reference is given, else use current time\n    const ref = options?.timeReference || this.currentTimeHHmm();\n    result = result.filter(r => this.withinBuffer(r.time, ref));\n\n    // sort by time ascending\n    result.sort((a, b) => this.toMinutes(a.time) - this.toMinutes(b.time));\n\n    return result;\n  }\n\n  bookRide(rideId: string, employeeId: string): { ok: true } | { ok: false; error: string } {\n    if (!employeeId.trim()) return { ok: false, error: 'Employee ID is required' };\n\n    const rides = this.loadTodayRides();\n    const idx = rides.findIndex(r => r.id === rideId);\n    if (idx === -1) return { ok: false, error: 'Ride not found' };\n\n    const ride = rides[idx];\n\n    if (ride.ownerEmployeeId === employeeId) {\n      return { ok: false, error: 'You cannot book your own ride' };\n    }\n\n    if (ride.bookings.includes(employeeId)) {\n      return { ok: false, error: 'You cannot book the same ride twice' };\n    }\n\n    if (ride.vacantSeats <= 0) {\n      return { ok: false, error: 'No vacant seats available' };\n    }\n\n    ride.bookings.push(employeeId);\n    ride.vacantSeats -= 1;\n\n    rides[idx] = ride;\n    this.saveTodayRides(rides);\n    return { ok: true };\n  }\n\n  currentTimeHHmm(): string {\n    const d = new Date();\n    const hh = String(d.getHours()).padStart(2, '0');\n    const mm = String(d.getMinutes()).padStart(2, '0');\n    return `${hh}:${mm}`;\n  }\n}\n"],"mappings":";AAIA,OAAM,MAAOA,WAAW;EADxBC,YAAA;IAEmB,KAAAC,kBAAkB,GAAG,QAAQ;IAC7B,KAAAC,mBAAmB,GAAG,EAAE;;EAEjCC,QAAQA,CAAA;IACd,MAAMC,CAAC,GAAG,IAAIC,IAAI,EAAE;IACpB,MAAMC,IAAI,GAAGF,CAAC,CAACG,WAAW,EAAE;IAC5B,MAAMC,EAAE,GAAGC,MAAM,CAACL,CAAC,CAACM,QAAQ,EAAE,GAAG,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;IACpD,MAAMC,EAAE,GAAGH,MAAM,CAACL,CAAC,CAACS,OAAO,EAAE,CAAC,CAACF,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;IAC/C,OAAO,GAAGL,IAAI,IAAIE,EAAE,IAAII,EAAE,EAAE;EAC9B;EAEQE,kBAAkBA,CAAA;IACxB,OAAO,IAAI,CAACb,kBAAkB,GAAG,IAAI,CAACE,QAAQ,EAAE;EAClD;EAEQY,cAAcA,CAAA;IACpB,MAAMC,GAAG,GAAG,IAAI,CAACF,kBAAkB,EAAE;IACrC,MAAMG,GAAG,GAAGC,YAAY,CAACC,OAAO,CAACH,GAAG,CAAC;IACrC,OAAOC,GAAG,GAAIG,IAAI,CAACC,KAAK,CAACJ,GAAG,CAAY,GAAG,EAAE;EAC/C;EAEQK,cAAcA,CAACC,KAAa;IAClC,MAAMP,GAAG,GAAG,IAAI,CAACF,kBAAkB,EAAE;IACrCI,YAAY,CAACM,OAAO,CAACR,GAAG,EAAEI,IAAI,CAACK,SAAS,CAACF,KAAK,CAAC,CAAC;EAClD;EAEQG,SAASA,CAACC,IAAY;IAC5B,MAAM,CAACC,CAAC,EAAEC,CAAC,CAAC,GAAGF,IAAI,CAACG,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,MAAM,CAAC;IAC1C,OAAOJ,CAAC,GAAG,EAAE,GAAGC,CAAC;EACnB;EAEQI,YAAYA,CAACC,MAAc,EAAEC,SAAiB;IACpD,MAAMC,CAAC,GAAG,IAAI,CAACV,SAAS,CAACQ,MAAM,CAAC;IAChC,MAAMG,CAAC,GAAG,IAAI,CAACX,SAAS,CAACS,SAAS,CAAC;IACnC,OAAOG,IAAI,CAACC,GAAG,CAACH,CAAC,GAAGC,CAAC,CAAC,IAAI,IAAI,CAACnC,mBAAmB;EACpD;EAEAsC,OAAOA,CAACC,KAQP;IACC;IACA,IAAI,CAACA,KAAK,CAACC,eAAe,CAACC,IAAI,EAAE,EAAE,OAAO;MAAEC,EAAE,EAAE,KAAK;MAAEC,KAAK,EAAE;IAAyB,CAAE;IACzF,IAAI,CAACJ,KAAK,CAACK,SAAS,CAACH,IAAI,EAAE,EAAE,OAAO;MAAEC,EAAE,EAAE,KAAK;MAAEC,KAAK,EAAE;IAAwB,CAAE;IAClF,IAAI,CAACJ,KAAK,CAACM,WAAW,CAACJ,IAAI,EAAE,EAAE,OAAO;MAAEC,EAAE,EAAE,KAAK;MAAEC,KAAK,EAAE;IAA2B,CAAE;IACvF,IAAI,CAACJ,KAAK,CAACO,WAAW,CAACL,IAAI,EAAE,EAAE,OAAO;MAAEC,EAAE,EAAE,KAAK;MAAEC,KAAK,EAAE;IAAyB,CAAE;IACrF,IAAI,CAAC,eAAe,CAACI,IAAI,CAACR,KAAK,CAACd,IAAI,CAAC,EAAE,OAAO;MAAEiB,EAAE,EAAE,KAAK;MAAEC,KAAK,EAAE;IAAoB,CAAE;IACxF,IAAIJ,KAAK,CAACS,WAAW,IAAI,IAAI,IAAIT,KAAK,CAACS,WAAW,GAAG,CAAC,EAAE,OAAO;MAAEN,EAAE,EAAE,KAAK;MAAEC,KAAK,EAAE;IAA2B,CAAE;IAEhH,MAAMtB,KAAK,GAAG,IAAI,CAACR,cAAc,EAAE;IAEnC;IACA,MAAMoC,WAAW,GAAG5B,KAAK,CAAC6B,IAAI,CAACf,CAAC,IAAIA,CAAC,CAACK,eAAe,KAAKD,KAAK,CAACC,eAAe,CAAC;IAChF,IAAIS,WAAW,EAAE;MACf,OAAO;QAAEP,EAAE,EAAE,KAAK;QAAEC,KAAK,EAAE;MAA8C,CAAE;;IAG7E,MAAMQ,IAAI,GAAS;MACjBC,EAAE,EAAEC,MAAM,CAACC,UAAU,GAAGD,MAAM,CAACC,UAAU,EAAE,GAAGlB,IAAI,CAACmB,MAAM,EAAE,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,KAAK,CAAC,CAAC,CAAC;MACjFjB,eAAe,EAAED,KAAK,CAACC,eAAe,CAACC,IAAI,EAAE;MAC7CiB,WAAW,EAAEnB,KAAK,CAACmB,WAAW;MAC9Bd,SAAS,EAAEL,KAAK,CAACK,SAAS,CAACH,IAAI,EAAE;MACjCO,WAAW,EAAET,KAAK,CAACS,WAAW;MAC9BvB,IAAI,EAAEc,KAAK,CAACd,IAAI;MAChBoB,WAAW,EAAEN,KAAK,CAACM,WAAW,CAACJ,IAAI,EAAE;MACrCK,WAAW,EAAEP,KAAK,CAACO,WAAW,CAACL,IAAI,EAAE;MACrCkB,QAAQ,EAAE,EAAE;MACZC,SAAS,EAAEzD,IAAI,CAAC0D,GAAG;KACpB;IAEDxC,KAAK,CAACyC,IAAI,CAACX,IAAI,CAAC;IAChB,IAAI,CAAC/B,cAAc,CAACC,KAAK,CAAC;IAC1B,OAAO;MAAEqB,EAAE,EAAE;IAAI,CAAE;EACrB;EAEAqB,SAASA,CAACC,OAAuH;IAC/H,MAAM3C,KAAK,GAAG,IAAI,CAACR,cAAc,EAAE;IACnC,IAAIoD,MAAM,GAAG5C,KAAK,CAACoC,KAAK,EAAE;IAE1B,IAAIO,OAAO,EAAEN,WAAW,IAAIM,OAAO,CAACN,WAAW,KAAK,KAAK,EAAE;MACzDO,MAAM,GAAGA,MAAM,CAACC,MAAM,CAAC/B,CAAC,IAAIA,CAAC,CAACuB,WAAW,KAAKM,OAAO,CAACN,WAAW,CAAC;;IAGpE,IAAIM,OAAO,EAAEG,YAAY,EAAE;MACzBF,MAAM,GAAGA,MAAM,CAACC,MAAM,CAAC/B,CAAC,IAAIA,CAAC,CAACK,eAAe,KAAKwB,OAAO,CAACG,YAAY,CAAC;;IAGzE,IAAIH,OAAO,EAAEI,aAAa,EAAE;MAC1BH,MAAM,GAAGA,MAAM,CAACC,MAAM,CAAC/B,CAAC,IAAIA,CAAC,CAACa,WAAW,GAAG,CAAC,CAAC;;IAGhD;IACA,MAAMqB,GAAG,GAAGL,OAAO,EAAEM,aAAa,IAAI,IAAI,CAACC,eAAe,EAAE;IAC5DN,MAAM,GAAGA,MAAM,CAACC,MAAM,CAAC/B,CAAC,IAAI,IAAI,CAACJ,YAAY,CAACI,CAAC,CAACV,IAAI,EAAE4C,GAAG,CAAC,CAAC;IAE3D;IACAJ,MAAM,CAACO,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK,IAAI,CAAClD,SAAS,CAACiD,CAAC,CAAChD,IAAI,CAAC,GAAG,IAAI,CAACD,SAAS,CAACkD,CAAC,CAACjD,IAAI,CAAC,CAAC;IAEtE,OAAOwC,MAAM;EACf;EAEAU,QAAQA,CAACC,MAAc,EAAEC,UAAkB;IACzC,IAAI,CAACA,UAAU,CAACpC,IAAI,EAAE,EAAE,OAAO;MAAEC,EAAE,EAAE,KAAK;MAAEC,KAAK,EAAE;IAAyB,CAAE;IAE9E,MAAMtB,KAAK,GAAG,IAAI,CAACR,cAAc,EAAE;IACnC,MAAMiE,GAAG,GAAGzD,KAAK,CAAC0D,SAAS,CAAC5C,CAAC,IAAIA,CAAC,CAACiB,EAAE,KAAKwB,MAAM,CAAC;IACjD,IAAIE,GAAG,KAAK,CAAC,CAAC,EAAE,OAAO;MAAEpC,EAAE,EAAE,KAAK;MAAEC,KAAK,EAAE;IAAgB,CAAE;IAE7D,MAAMQ,IAAI,GAAG9B,KAAK,CAACyD,GAAG,CAAC;IAEvB,IAAI3B,IAAI,CAACX,eAAe,KAAKqC,UAAU,EAAE;MACvC,OAAO;QAAEnC,EAAE,EAAE,KAAK;QAAEC,KAAK,EAAE;MAA+B,CAAE;;IAG9D,IAAIQ,IAAI,CAACQ,QAAQ,CAACqB,QAAQ,CAACH,UAAU,CAAC,EAAE;MACtC,OAAO;QAAEnC,EAAE,EAAE,KAAK;QAAEC,KAAK,EAAE;MAAqC,CAAE;;IAGpE,IAAIQ,IAAI,CAACH,WAAW,IAAI,CAAC,EAAE;MACzB,OAAO;QAAEN,EAAE,EAAE,KAAK;QAAEC,KAAK,EAAE;MAA2B,CAAE;;IAG1DQ,IAAI,CAACQ,QAAQ,CAACG,IAAI,CAACe,UAAU,CAAC;IAC9B1B,IAAI,CAACH,WAAW,IAAI,CAAC;IAErB3B,KAAK,CAACyD,GAAG,CAAC,GAAG3B,IAAI;IACjB,IAAI,CAAC/B,cAAc,CAACC,KAAK,CAAC;IAC1B,OAAO;MAAEqB,EAAE,EAAE;IAAI,CAAE;EACrB;EAEA6B,eAAeA,CAAA;IACb,MAAMrE,CAAC,GAAG,IAAIC,IAAI,EAAE;IACpB,MAAM8E,EAAE,GAAG1E,MAAM,CAACL,CAAC,CAACgF,QAAQ,EAAE,CAAC,CAACzE,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;IAChD,MAAMH,EAAE,GAAGC,MAAM,CAACL,CAAC,CAACiF,UAAU,EAAE,CAAC,CAAC1E,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;IAClD,OAAO,GAAGwE,EAAE,IAAI3E,EAAE,EAAE;EACtB;;;uBA7IWT,WAAW;IAAA;EAAA;;;aAAXA,WAAW;MAAAuF,OAAA,EAAXvF,WAAW,CAAAwF,IAAA;MAAAC,UAAA,EADE;IAAM;EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}